less:
The assumption for less(X,Y) is that it returns TRUE if X is a nats representation of a number that is less than the number Y represents. If either are variables, it must run through all possibilities that would make the statement TRUE.
There are four success cases for less(X,Y):
X is a variable, Y is a nat
Y is a nat, X is a variable
X and Y are nats, with X representing a nat less than Y represents
X and Y are both variables

For the case where X is a variable, and Y is a nat, prolog returns X as a series of nats less than Y, starting from z in increasing order.

For the case where Y is a variable and X is a nat, prolog returns Y as a single value of s(s(...s(_)...)) with 1 more s(...) in Y than in X.

For the case where both are Nats, and X is less than Y, prolog simply returns true.

For the case where both are variables, prolog returns X as a series of nats, starting from z and increasing by 1, and Y as a series s(...s(_)...) always with 1 more s(...) than in X.

I argue that this is correct because this input has been tested for values 0-10 for both X and Y in all four cases, with the results the same as the cases explained above.

Additionally, less FAILS if either input is not of the form s(s(...(z)...) or s(s(...(_)...) or a variable.
For inputs of the form s(...(_)...), which technically mean n-th successor of any nat, both X and Y are always satisfied, so prolog returns X from z upwards, and Y from s(s(...(_)...)) n+1-th successor and upwards. I would argue that this is desirable, and is correct, as it is in line with the stated assumption.

checkset:
The assumption for checkset(X) is that it returns TRUE if X is a valid nats set. There is no necessary behavior for X as an uninitiated variable.
There are two success cases for checkset(X):
X is the empty list []
X is a list containing only nats in strictly ascending order, i.e. if we have [A|[B|[Tail]], less(A, B) is TRUE.

checkset FAILS if the elements are out of order, if the list contains an element which is NOT a nat, or if the list contains duplicates.

I argue that this is correct because it has been tested for permutations of lists up to size 5 of values 0-5.
If X is left as a variable, prolog attempts to create a list. First comes the empty set, followed by the singleton [z], then [s(z)] and so on in this manner. This is not incorrect, as these are all valid sets of size 1. Coupling checkset(X) with length(X,Y) gives valid sets of the specified size, although they all begin [z,s(z),s(s(z))...] with only the last item in the list incrementing every iteration. Again, this is not wrong. They are valid sets of the given size.

ismember:
The assumption for ismember(X,Y,Val) is that Val is yes if X is a nats element of nats set Y, and no if X is a nats element that does NOT belong to nats set Y. Furthermore, leaving X and Val as variables, X and Val are expected to run through every possible value of the given set Y, from X = z to X = s(+(n...(_)...)) where n is the highest value in Y, returning the appropriate yes or no value. Finally, our version implements the ability to leave Y as a variable as well, and have ismember generate the appropriate sets Y paired with the appropriate values for Val and/or X.
ismember should actually always succeed, as long as X is a nat, Val is either yes or no, and Y is a list of nats (unfortunately checking if it is a set destroys our ability to generate sets, somewhat paradoxically.) ismember3, however, switches this. By keeping the coding simpler and not requiring ismember to return a set Y for a given X and Val, we can ensure that ismember fails to unify when given a non-set Y by requiring checkset(Y) to be included.

I argue that this is correct because it has been tested for lists of nats Y of size 5 for values 0-10, compared against nats X for values 0-15, with the results always as expected. In addition, the sets generated by ismember are the simplest possible sets that meet the conditions layed out by X and Val, although perhaps not in the expected order.

ismember3 is also correct based on the stated assumptions, and tested over the same intervals. It has further strength because it does not allow non-sets to be used as input, but does not generate appropriate sets if the set variable Y is left blank. As this is not part of the assignment, it is considered by me to be correct.

Running the example code of | ?- ismember(N,[s(z),s(s(s(z))),A).

yields the following process:
1,  prolog unifies ismember(N,S,A) with ismember2(N,S,A,z).
2,  prolog attempts to unify ismember2(N,S,A,z) with (_,[],no,_).
	No success, because S is non-empty.
3,  prolog attempts to unify (N,S,A,z) with (Num, [Num|_], yes, _).
	Since N is a variable, N unifies with Num, and A unifies with yes.
4,  prolog next attempts to unify (N,S,A,z) with (Num, [Head|Tail], Val, Last).
	Unification is possible, but now we check the additional constraints that Head is less than Num, which forces num to take the value s(s(_)) for the moment, and that Last is less than Head, which forces prolog to stay within the constraints of a set. Finally, we attempt to recursively unify with (Num, Tail, Val, Head). Success.
5,  Attempt (N,S,A,s(z)) with (_,[],no,_).
	No success because S is non-empty.
6,  Attempt (N,S,A,s(z)) with (Num, [Num|_], yes, _).
	Success, because N = s(s(_)), and S = [s(s(s(z)))|_] can be unified, so that N = s(s(s(z))).
7,  Attempt (N,S,A,s(z)) with (Num, [Head|Tail], Val, Last).
	Unification is possible. Additional constraints require that N, currently s(s(_)), is now less than Head, currently s(s(s(z))). Thus N is updated to s(s(s(s(_)))). Finally, recurse.
8,  Attempt (N,S,A,s(s(s(z)))) with (_,[],no,_).
	Success, because S is now the empty set.
9,  Attempt (N,S,A,s(s(s(z)))) with (Num, [Num|_], yes, _).
	No success, because S is the empty set.
10, Attempt (N,S,A,s(s(s(z)))) with (Num, [Head|Tail], Val, Last).
	No success, because S is the empty set.
11, Attempt (N,S,A,s(s(s(z)))) with (Num, [Head|_], no).
	No success, because S is the empty set.
12, Backtrack to step 7.
13, Attempt (N,S,A,s(z)) with (Num, [Head|_], no).
	Unification is possible. N is s(s(_)), Head is s(s(s(z))). The requirement that Num is less than Head forces n to take the value s(s(z)). A returns no.
14, Backtrack to step 4.
15, Attempt (N,S,A,z) with (Num, [Head|_], no).
	Unification is possible. N is any variable. Head is s(z). the constrain that Num is less than Head forces N to take the value z. A returns no.
16, Backtrack to 1.
17, Attempt ismember(N,[z|S],A) with ismember2(N,S,A,z).
	No success, because z is not the first element of our set.
18, Possibilities are exhausted, prolog returns no.

The reason we have included this additional "last" variable is so that if we give a variable for the set, we can correctly generate sets.
The example code works precisely the same way with ismember3, with the exception that we don't pass the previous values down, as there is no need to since we are not worried about set generation.

For the purposes of testing quality, we created a few predicates:

i2n(Int,Nat)
minimum(Val,List)
remove(Val,Prevlist,Outlist)
popmin(Prevlist,Outlist,Minimumval)
genset(List,Set)
genlist(List,Natlist)
genintlist(Min,Max,Length,List)
between(Min,Max,Val)
genints(Min,Max,List)
genlists(Min,Max,Natlist)
gensets(Min,Max,Set)

The behavior of each of these functions is documented in the code. They make use of several of prolog's built-in predicates, but since they are functions we only used to test our code, we do not consider this to be a problem.
______________________________Union testing
We argue that union(X,Y,Z) is correct because it has been tested using lists of nats of length 5, from values 0-5, for X, Y, and Z, and alternately using one of each of the three as variables instead of fixed. The results were always what was expected. Additionally, when given only a set Z and leaving X and Y variables, all possible correct combinations are returned for X and Y. When all three are uninstantiated variables, X remains the empty set [], while Y and Z progress through the singletons from [z] upwards. When providing either X or Y (Without loss of generality, X is provided), and leaving Y and Z uninstantiated, Y progresses through the singletons from one higher than the highest value of X. This occurs because of the ordering of the union2 predicates. Empty sets and small sets take precedence, so those are the first sets to be returned. Since there are infinitely many cases, we only see Y return singleton values!

______________________________Intersection testing
We argue that intersection(X,Y,Z) is correct because it has been tested using lists of nats of length 5, from values 0-5, for X, Y, and Z, and alternately using Z as a variable. The results were always correct sets. Interestingly, when using either X or Y as variables, and providing the other two with values, prolog returns local stack overflow errors. This is because in the search for a possible unification, for example intersection(X, [s(z),s(s(z))], [s(z),s(s(z))]), prolog checks sets of the form [z,s(z)] -> [z,s(s(z))] -> [z, s(s(s(z)))] -> ... infinitely. This is undesirable, but not wrong as the behavior of the predicate when given uninstantiated variables is not defined. Amusingly, given Z and either X or Y (WLOG, Y is uninstantiated, X is provided) as uninstantiated variables, Z remains the empty set [], Y begins as the empty set [], and then Y progresses sequentially through the singletons from one higher than the highest value of X upwards. It's not wrong, but it does look funny. The reason this occurs is because of the way the intersection2 predicates are ordered. Since the empty set cases all occur higher than any other, those are the ones that take precedence. Since there are infinitely many, we will always recieve an empty Z in return. If the ordering of code was re-arranged, we would recieve a different group of sets.

Hi Jens! Good lunch?
